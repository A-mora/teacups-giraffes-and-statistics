---
title: "Introduction to the R programming language"
output:
  bookdown::html_document2:
    includes:
      in_header: Intro_to_R_image.html
      after_body: foot.html
---

Throughout this material we will use an interactive version of R provided by [DataCamp](datacamp.com). Although this way of using R comes with some limitations regarding functionality, it will give us the benefit of being able to run R code without switching from a web browser to a standalone application such as [RStudio](rstudio.com). Below you can see an example of an interactive R window. On the left side of the window (under the tab titled *script.R*) is where you will write code to be executed in R. To run code you have written, click the yellow *Run* button and observe how the right side of the window gets filled with information. A copy of your code will show up in black and if no errors where made the answer will be returned right below in brown text. Error messages are red and begin with *Error:*. Now spend a few minutes using the *Script* window below as a calculator and run simple calculations by clicking *Run*.

```{r, include=FALSE}
tutorial::go_interactive(height = 160)
```

```{r}
2+3
```

R is an object oriented programming language, meaning when working in R we w
ill create different types of objects and use operators and functions to manipulate these objects. 

To create a new object in R we first pick a name for the object and tell R what to assign to it using assignment operators; either `=` or the combination of `<` and `-` creating a small arrow `<-`. Use the window below to assign numbers to objects and output the content by typing out the name of the object. After creating two numerical objects, use the mathematical operator `+` to add these objects together and see what happens when you run the code. 

```{r}
my_object <- 
my_object

my_object2 <- 

my_object + my_object2
```

Most of the time when we work in R, we will use functions; either pre-written functions or ones we write ourselves. Functions make it easy to use sets of code instructions repeatedly (without filling our scripts with the code underlying the function) and help us carry out specific tasks without every time having to go through the details of how the task is executed. To use functions in R, we type the name of the function followed by parentheses (e.g. `print()`). Within the parentheses is where we will specify the function input and options, separated by commas `,`. One function you will use a lot is the *combine* function (`c()`), which as the name suggests lets you combine different types of values. In the window below, create an object combining a set of numerical values using `c()`, and use `,` to separate the different values. Then sum up the content of this object using `sum()`.

```{r}
my_combined_values <- c(,) 
sum(my_combined_values)
```

R makes it easy to create user defined functions by using `function()`. Here is how it works:

  * Give your function an object name and assign the function to it, e.g. `my_function <- function()`. 
  * Within the parentheses you specify inputs and options just like how pre-written functions work, e.g. `function(input_data)`
  * Next, put all the code you want your function to execute inside curly brackets like this: `function(input_data){code to run}`
  * Use `return()` to specify what you want to your function to output once it is done running the code. 
  
In the window below first create a object containing a set of numerical values. Then complete the function taking this object as input, summing up the values and taking the square root of the sum. To take the square root, we use the `sqrt()` function. 

```{r}
my_combined_values <- c(,) 
my_function <- function(input_data){
  s <- sum()
  ss <- sqrt()
  return()
}
my_function(my_combined_values)
```

It is also possible (and sometimes very useful) to put a function within another function. For example, we could combine two of the step in the window above like this: `my_function(c(2,2))`, resulting in one line of code both generating the values and directly calculating the square root of the sum of them.  

The `c()` function will combine values and create a specific type of data structure called an *atomic vector*. A vector is a simple one-dimensional structure that can contain only one type of values. This means that storing multiple numeric values in a vector, as we have already done, works just fine. But there are other types of values that can be used in R, for example *character* values. These values are created by putting text or numbers within quotes such as `"Giraffe"`. If we try to combine numeric and a character values in the same vector, R will convert both values to the character type.  

```{r, tut=FALSE}
c("Giraffe", 123)
```

This behavior is not always desirable, so it is a good idea to try to only combine values of the same type

Another type of variable in R is the boolean (TRUE/FALSE) type. Boolean or logical vectors can only take two different values; TRUE of FALSE (case sensitive). You will see these types of values mostly when logical operators (e.g. are used to test how different objects relate to each other. For example, the logical operator `==` can be used to tests if two different objects are exactly the same and `TRUE` will be returned if identity is fulfilled. 


```{r, tut=FALSE}
"Giraffe"=="Teacup"
sqrt(100)==10
```

Vectors are one of multiple data structures in R. We will not cover all types of structures here, but the perhaps most common one encountered when analyzing data in R is the *data frame*. Data frames are two dimensional, which basically means that data frames let you store multiple vectors as columns in one object. One constraint though is that all vectors/columns need to be of the same length. In the window below, use the `data.frame()` function to create a data frame with two columns called *x* and *y*. When creating data frames we specify a column by giving it a name and assigning values to it, e.g. `data.frame(x=c("Giraffe", "Teacup"))`. Also observe what happens when you try to combine a x and y vector of different lengths. 

```{r}
x <- c(,)
y <- c(,)
d <- data.frame(x=x, y=y)
d
```

As you could see above, running a line of code with just the name of a data structure (in this case just the letter *d*) will print the full data frame in the console output (if no errors were made!). If you instead are interested in only one of the columns, this can be specified by using the `$` operator, e.g `d$x`. Try it out below!

```{r}
d <- data.frame(x=c(10, 45), y=c(2, 5))
d$
```
